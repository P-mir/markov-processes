---
lang: fr-FR
geometry: top=2cm,bottom=2cm

output:
  pdf_document: 
  df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(comment = "")
path = 'C:/Users/p/Documents/GitHub/markov-processes'
```
<!-- \graphicspath{ {(C:/Users/Guillaume/Documents/GitHub/markov-processes/} } -->
\graphicspath{ {(path/} }



\begin{figure}[h]
\includegraphics{titlepage.PNG}
\centering
\end{figure}

\clearpage
\newpage

'\tableofcontents'

\newpage

```{r,include=F}
#---------CHARGEMENT DES SCRIPTS---------------------------------------------
#setwd("~/GitHub/markov-processes")
setwd(path)
source('transition_matrix.R')
source('value_iteration.R')
source('simulation_game.R')

library(knitr)
```


# 1. Introduction et explication du jeu 

L'objectif du projet est de mettre en application les processus de décision markovien sur un jeu de l'oie.
Ce dernier est modélisé de la manière suivante : 


\begin{figure}[h]
\caption{Schéma du jeu de l'oie modifié}
\includegraphics{jeu de l'oie.PNG}
\centering
\end{figure}

Pour commencer, nous avons initialisé le jeu avec deux pièges. Le premier est situé sur la case 7 et le second sur la case 13. Le premier, en cas d'activation, fait reculer le joueur de 3 cases jusqu'à la case 4. Le second piège, quant à lui, ramène le joueur à la case 1. Il est important de préciser que le piège a une chance de s'activer dès que le joueur arrive sur la case piégée. Exemple : Le joueur démarre de la case 5 et réalise un 2 en jouant le dé normal, il arrivera donc sur la case 7. Le joueur a, dès lors, une chance sur deux de rester sur la case 7 ou de reculer de 3 cases. Cependant au prochain tour, le piège peut à nouveau s'activer si le joueur réalise un 0 (sauf s'il a joué le dé de sécurité).

Ensuite, le jeu sera joué selon deux règles différentes. La première règle stipule que le joueur gagne le jeu dès qu'il (dé)passe la case 15. La seconde règle qui est plus stricte exige à ce que le joueur arrive exactement sur la case 15 pour gagner le jeu. 


Pour la suite du projet, nous allons tout d'abord définir la stratégie optimale à jouer selon la règle en vigueur (règle 1 ou règle 2) grâce aux processus de decision markoviens. Ensuite nous simulerons différentes parties afin de, tout d'abord, comparer les résultats théoriques et empiriques de la stratégie optimale mais également de comparer cette dernière avec d'autres stratégies qui seront normalement moins efficaces (jouer toujours le même dé ou jouer aléatoirement). 


# 2. Théorie : algorithme d'itération de la valeur

Afin de trouver la stratégie optimale à jouer nous nous basons sur la méthode de programmation dynamique de Richard Bellman. Le problème est divisé en sous-problèmes: trouver la stratégie optimale pour chaque case.

Ce jeu peut être vu comme un processus stochastique pour lequel le futur est independant du passé, étant donné le présent. (propriété de Markov)

Autrement dit si $X_{n}$ est la stratégie du joueur à la case n et $X_{n-1}$ la stratégie jouée à la case précédant n, on a alors:

$\mathbb{P}(X_n=x_n\mid X_{n-1}=x_{n-1}, \dots, X_0=x_0)=\mathbb{P}(X_n=x_n\mid X_{n-1}=x_{n-1}).$


\newpage

Pour résoudre ce processus de décision markovien, une "politique" de jeu optimale peut ainsi être trouvée à l'aide de l'algorithme de la "value iteration". Ce dernier se base sur l'équation de Bellman pour calculer de manière récursive le coût optimal esperé:


\[ \hat{V}(k) \leftarrow  \min_{a \in U_{k}} \bigg\{ c(a,k)+ \sum_{k'} p(k'|k,a) V^*(k')]\bigg\} \\ \hat{V}(d) \leftarrow0 , \text{où d est la case finale.}  \]

Avec :

$\hat{V}(k)$ le coût attendu de la case k.

$p(k'|k,a)$ la probabilité d'atteindre la case $k'$ en jouant l'action $a$ depuis la case $k$.

$c(a,k)$ le coût de realisation de l'action a à la case k, ici 1 à chaque fois.


L'action optimale a la case k est alors:

\[ {\arg\!\min}_{a \in U_{k}} \bigg\{ c(a,k)+ \sum_{k'} p(k'|k,a) V^*(k')]\bigg\} \]


# 3. Simulation du jeu

Pour la simulation, afin d'obtenir des résultats précis, nous itérerons chaque partie 10 000 fois. Ces dernières seront jouées selon 5 stratégies différentes :

* La stratégie optimale définie dans la partie 2 selon la règle jouée
* Toujours le dé "sécurité" (dé 1)
* Toujours le dé "normal" (dé 2)
* Toujours le dé "risqué" (dé 3)
* Stratégie définie de manière aléatoire

\newpage

## 3.1 Simulation selon la règle 1

Nous allons tout d'abord jouer selon la règle 1 qui est dîte souple. Ci-dessous, nous vous présentons les résultats des 10 000 parties jouées selon les différentes stratégies. Pour chaque partie, nous la débutons à partir de la case 1.

\begin{figure}[h]
\caption{Boxplots - Règle 1 }
\includegraphics[height=7cm]{Boxplot_rule1.pdf}
\centering
\end{figure}

Nous pouvons déjà constater, qu'au départ de la case une, la stratégie optimale a de meilleurs résultats en moyenne par rapport aux 4 autres stratégies. La stratégie la moins efficace semble être celle qui joue toujours le dé de sécurité. De manière intuitive, ce résultat est cohérent car nous ne risquons pas de revenir aux premières cases lorsque nous dépassons la case 15.

Ensuite, nous pouvons comparer les resultats des différentes stratégies au départ de n'importe quelle case du jeu. Le tableau, ci-dessous vous présente le nombre d'itérations moyen nécessaire pour terminer le jeu en fonction de la case où le jeu a débuté.

```{r,include=T,echo=F}
result_matrix_rule1 <- read.table("result_matrix_rule1.txt")
colnames(result_matrix_rule1) <- c("Optimal policy","Dice 1","Dice 2", "Dice 3", "Random dice")
rownames(result_matrix_rule1)<- c("Square 1","Square 2","Square 3","Square 4","Square 5","Square 6","Square 7","Square 8","Square 9","Square 10","Square 11","Square 12","Square 13","Square 14")

kable(round(result_matrix_rule1,2),caption="Nombre d'itérations moyen en fonction de la case de départ")
```



Nous pouvons constater que la stratégie optimale est, en moyenne, soit meilleure ou équivalente aux autres stratégies de jeu quelque soit la case de départ. D'ailleurs, la stratégie de toujours jouer le dé risqué est assez similaire à la stratégie optimale. Ceci n'est pas étonnant car cette dernière préconise de jouer le dé risqué dans 12 cas sur 15. Cependant, si nous analysons l'écart-type des resultats des différentes stratégies, nous pouvons remarquer que la stratégie optimale fournit bien un résultat moins variable que la stratégie du dé risqué.


```{r,include=T,echo=F}
variance_matrix_rule1<-read.table("variance_matrix_rule1.txt")
colnames(variance_matrix_rule1) <- c("Optimal policy","Dice 1","Dice 2", "Dice 3", "Random dice")
kable(round(variance_matrix_rule1,2),caption="Variance des différentes stratégies")
```


## 3.2 Simulation selon la règle 2

Nous allons maintenant changer la règle du jeu en obligeant le joueur de tomber exactement sur la case 15 afin de remporter la partie. Ci-dessous, retrouvez les résultats des differentes stratégies au départ de la case 1.

\begin{figure}[h]
\caption{Boxplots - Règle 2 }
\includegraphics[height=8cm]{Boxplot_rule2.pdf}
\centering
\end{figure}

Selon la règle 2, jouer la stratégie optimale semble être plus efficace que les 4 autres stratégies. Contrairement au cas de la règle 1, ici c'est la stratégie du dé 1 qui semble se rapprocher de la stratégie optimale. Ceci est cohérent du au fait que nous revenons aux cases de départ si la case 15 est dépassée.

\newpage

Nous pouvons également analyser le résultat moyen au départ de n'importe quelle case du jeu :

```{r,include=T,echo=F}
result_matrix_rule2 <- read.table("result_matrix_rule2.txt")
colnames(result_matrix_rule2) <- c("Optimal policy","Dice 1","Dice 2", "Dice 3", "Random dice")
rownames(result_matrix_rule2)<- c("Square 1","Square 2","Square 3","Square 4","Square 5","Square 6","Square 7","Square 8","Square 9","Square 10","Square 11","Square 12","Square 13","Square 14")

kable(round(result_matrix_rule2,2),caption="Nombre d'itérations moyen en fonction de la case de départ")
```

En analysant en détail, il apparaît clairement, que pour toutes les cases, la stratégie optimale est meilleure que n'importe quelle autre stratégie sauf pour la case 14 avec la stratégie du dé 1. En effet, la stratégie optimale préconise de jouer le dé sécurité pour l'avant dernière case du jeu.

Nous pouvons également comparer l'indice de dispersion pour les resultats des différentes stratégies :

```{r,include=T,echo=F}
variance_matrix_rule2<-read.table("variance_matrix_rule2.txt")
colnames(variance_matrix_rule2) <- c("Optimal policy","Dice 1","Dice 2", "Dice 3", "Random dice")
kable(round(variance_matrix_rule2,2),caption="Variance des différentes stratégies")
```

En plus de présenter le meilleur résultat moyen, la stratégie optimale est celle qui présente également une performance la moins variable dans le contexte de la règle 2. Ceci confirme qu'elle est belle est bien la plus éfficace.

\newpage

# 4. Adaptation du jeu

# 4.1 Ajout d'un ralentisseur

Nous avons ensuite ajouté un piège en case 9 qui ralentit le joueur si il est activé. Par exemple si le joueur arrive en case 9 et active le piège, il avancera au tour suivant selon le chiffre tiré par son dé, moins une case. Comme illustré ci-dessous, cela revient à ajouter une case à notre jeu pour porter le nombre de cases à 16, si le piège est activé le joueur fait un détour en case 10.

\begin{figure}[h]
\caption{Schéma conceptuel du jeu de l'oie avec un piège ralentisseur en case 9.}
\includegraphics{schema2.PNG}
\end{figure}

```{r,include=T,echo=F}
```


# 4.2 Analyses des différentes stratégies selon le plateau de jeu

```{r,include=T,echo=F}

policy_matrix <- matrix(data=c(c(3,3,2,2,3,3,3,3,3,3,3,3,1,3,'NA'),
                               c(3,3,2,2,3,3,3,3,2,1,3,3,2,1,'NA'),
                               c(3,3,2,2,3,3,3,3,3,3,3,3,3,1,3),
                               c(3,3,2,2,3,3,3,3,3,2,1,3,3,2,1)),
                              nrow=4,
                              ncol=15,
                              byrow=TRUE)

rownames(policy_matrix)<- c("Jeu avec la règle 1","jeu avec la règle 2","jeu avec la règle 1,avec ralentisseur","jeu avec la règle 2,avec ralentisseur")

colnames(policy_matrix)<- c("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15")

kable(policy_matrix,caption="dé choisi par la police optimale en fonction de la case")
```

Les résultats ci-dessus nous permettent de mesurer l'effet qu'un changement des règles du jeu peut produire sur la stratégie optimale adopté. La règle qui fait recommencer le joueur depuis le début si il dépasse la case 15, rend le joueur plus prudent à l'approche de la fin du plateau de jeu (cases 9,10,13 et 14).

On s'intérèsse maintenant à l'effet du piège ralentisseur en comparant les deux premières lignes du tableau aux deux dernières. il faut garder en tête qu'il y a un décalage d'une case à partir de la colonne 10 de notre tableau car une case "artificielle" a été créee dans ce cas et porte à 16 le nombre total d'états. 
Compte tenu de ça on peut observer que la stratégie du joueur n'est pas affecté par ce piège, et continue de jouer le dé 3 à son approche, sans doute car la pénalité de ce piège n'est pas assez forte.

Finalement on peut remarquer que le joueur ne choisit jamais le dé 3 en cases 3 ou 4. En effet avancer de trois cases depuis la case 3 signifie risquer d'activer le piège en case 13 et retourner à la case 1, tandis que trois cases après la case 4 on peut trouver un autre piège en case 7 qui fait reculer de trois cases.


# 6. Annexe


## 6.1 Simulation selon la règle 1 en ajoutant un piège ralentisseur.
```{r,include=T,echo=F}
result_matrix_rule1_prison <- read.table("result_matrix_rule1_prison.txt")
colnames(result_matrix_rule1_prison) <- c("Optimal policy","Dice 1","Dice 2", "Dice 3", "Random dice")
rownames(result_matrix_rule1_prison)<- c("Square 1","Square 2","Square 3","Square 4","Square 5","Square 6","Square 7","Square 8","Square 9","Square 10","Square 11","Square 12","Square 13","Square 14","Square 15")

kable(round(result_matrix_rule1_prison,2),caption="Nombre d'itérations moyen en fonction de la case de départ")
```

\newpage

## 6.1 Simulation selon la règle 2 en ajoutant un piège ralentisseur.

```{r,include=T,echo=F}
result_matrix_rule2_prison <- read.table("result_matrix_rule2_prison.txt")
colnames(result_matrix_rule2_prison) <- c("Optimal policy","Dice 1","Dice 2", "Dice 3", "Random dice")
rownames(result_matrix_rule2_prison)<- c("Square 1","Square 2","Square 3","Square 4","Square 5","Square 6","Square 7","Square 8","Square 9","Square 10","Square 11","Square 12","Square 13","Square 14","Square 15")

kable(round(result_matrix_rule2_prison,2),caption="Nombre d'itérations moyen en fonction de la case de départ")
```



